{"status":{},"spec":{"name":"Clone VPC","description":"","resources":{"service_definition_list":[{"name":"Service1","description":"","variable_list":[],"action_list":[{"type":"system","name":"action_create","description":"System action for creating an application","runbook":{"name":"e297de53_runbook","description":"","task_definition_list":[{"type":"DAG","name":"f64c37e3_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[{"name":"Clone the Environment","kind":"app_task"}],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"timeout_secs":"0","retries":"0","inherit_target":false},{"type":"EXEC","name":"Clone the Environment","description":"","attrs":{"type":"","script":"#!\/usr\/bin\/env python\n\nimport os\nimport time\nimport math\n\nfrom dotenv import load_dotenv\nimport ntnx_networking_py_client\nimport ntnx_vmm_py_client\nimport ntnx_prism_py_client\nimport ntnx_networking_py_client.models\nimport ntnx_networking_py_client.models.networking\nimport ntnx_networking_py_client.models.common.v1.config as v1CommonConfig\nimport ntnx_networking_py_client.models.networking.v4.config as v4NetConfig\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.CloneOverrideParams import CloneOverrideParams\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.Nic import Nic\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.NicNetworkInfo import NicNetworkInfo\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.SubnetReference import SubnetReference\nfrom ntnx_vmm_py_client.rest import ApiException as VMMException\n\nimport urllib3\nurllib3.disable_warnings()\n\n# Load environment variables\nload_dotenv()\n\n# Customizable variables\nprismCentralIp = \"@@{pcAddress}@@\"  # Prism Central IP\npcUsername = \"@@{pcUser.username}@@\"  # Nutanix username\npcPassword = \"@@{pcUser.secret}@@\"  # Nutanix password\nvpcName = \"@@{vpcName}@@\"\ncategoryName = \"@@{categoryName}@@\"\ncategoryValue = \"@@{categoryValue}@@\"\nexternalNetworkName = \"@@{externalNetworkName}@@\"\ncategoryFloatingIPName = \"@@{categoryFloatingIPName}@@\"\n\n# Retry parameters\nmax_wait_time = 60  # maximum wait time in seconds\ninterval = 1        # interval between retries in seconds\n\n# Subnet configuration\nsubnetList = {\n    \"vpc-\"+vpcName+\"-subnet\": {\n        \"subnetDescription\": \"This is the overlay subnet\",\n        \"ipNetwork\": \"172.24.0.0\",\n        \"ipPrefix\": 16,\n        \"ipGateway\": \"172.24.0.1\",\n        \"ipPoolStart\": \"172.24.32.10\",\n        \"ipPoolEnd\": \"172.24.47.254\"\n    },\n}\n\n#########################################\n# SDK Client Configuration\n#########################################\n\n# Configure the client\nsdkConfig = ntnx_networking_py_client.Configuration()\nsdkConfig.host = prismCentralIp\nsdkConfig.port = 9440\nsdkConfig.maxRetryAttempts = 3\nsdkConfig.backoffFactor = 3\nsdkConfig.username = pcUsername\nsdkConfig.password = pcPassword\nsdkConfig.verify_ssl = False\n\n# Function to create a VPC\ndef createVpc(vpcName):\n    print(\"Creating VPC: %s\" % vpcName)\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n    vpc = ntnx_networking_py_client.Vpc()\n    externalSubnet = ntnx_networking_py_client.ExternalSubnet()\n    externalSubnet.subnet_reference = retrieveNetworkId(externalNetworkName)\n    vpc.name = vpcName  # Required field\n    vpc.external_subnets = [externalSubnet]\n\n    try:\n        response = vpcsApi.create_vpc(body=vpc)\n        return True\n    except ntnx_networking_py_client.rest.ApiException as e:\n        return False\n\n# Function to check if a VPC exists\ndef checkVpcExists(vpcData, vpcName):\n    if vpcData:\n      for vpc in vpcData:\n          if vpc.name == vpcName:\n              return vpc._ExternalizableAbstractModel__ext_id\n    return False\n\n# Function to wait for VPC creation\ndef waitForVpcCreation(vpcName, timeout=3000, interval=1):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n    vpcs = vpcsApi.list_vpcs()\n\n    elapsedTime = 0\n    while elapsedTime < timeout:\n        vpcId = checkVpcExists(vpcs.data, vpcName)\n        if vpcId:\n            return vpcId\n        else:\n            time.sleep(interval)\n            elapsedTime += interval\n\n    return False\n\n# Function to create an overlay subnet\ndef createOverlaySubnet(vpcId, subnetName, ipNetwork, ipPrefix, ipGateway, ipPoolStart, ipPoolEnd):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetsApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n    subnet = ntnx_networking_py_client.Subnet()\n\n    print(\"Creating overlay subnet...\")\n\n    # Set up the subnet configuration\n    subnet.name = subnetName\n    subnet.subnet_type = ntnx_networking_py_client.SubnetType.OVERLAY  # Required field\n    subnet.vpc_reference = vpcId\n\n    subnet.ip_config = [\n        v4NetConfig.IPConfig.IPConfig(\n            ipv4=v4NetConfig.IPv4Config.IPv4Config(\n                default_gateway_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                    prefix_length=ipPrefix,\n                    value=ipGateway,\n                ),\n                ip_subnet=v4NetConfig.IPv4Subnet.IPv4Subnet(\n                    ip=v1CommonConfig.IPv4Address.IPv4Address(\n                        prefix_length=ipPrefix,\n                        value=ipNetwork,\n                    ),\n                    prefix_length=ipPrefix,\n                ),\n                pool_list=[\n                    v4NetConfig.IPv4Pool.IPv4Pool(\n                        start_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                            prefix_length=ipPrefix,\n                            value=ipPoolStart,\n                        ),\n                        end_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                            prefix_length=ipPrefix,\n                            value=ipPoolEnd,\n                        )\n                    )\n                ],\n            )\n        )\n    ]\n\n    try:\n        subnetsApi.create_subnet(body=subnet)\n        print(\"Done...\")\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n# Function to retrieve subnets in a VPC\ndef retrieveVpcSubnets(vpcId, timeout=3000, interval=1):\n    subnetList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    while page < nbPages:\n        response = subnetApi.list_subnets(_page=page, _limit=limitPerPage, _filter=\"vpcReference eq '\" + vpcId + \"'\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        for item in myData['data']:\n            subnetList.append({'name': item['name'], 'ext_id': item['ext_id']})\n        page += 1\n\n    return subnetList\n\n# Function to retrieve the extId of a specific subnet\ndef retrieveNetworkId(networkName):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    response = subnetApi.list_subnets(_filter=\"name eq '\" + str(networkName) + \"'\")\n    myData = response.to_dict()\n\n    if myData['data']:\n        return myData['data'][0]['ext_id']\n    else:\n        return None\n\n# Function to get VMs by categories\ndef getVmsByCategories(categoryName, categoryValue):\n    vmList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    categoryId = getCategoryId(categoryName, categoryValue)\n\n    while page < nbPages:\n        # Temporary filter only on VM starting with 'hol' to bypass the UEFI issue\n        response = vmApi.list_vms(_page=page, _limit=limitPerPage, _orderby=\"name asc\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        if myData['data'] and len(myData['data']):\n            for item in myData['data']:\n                if item.get('categories') is not None:\n                    for category in item['categories']:\n                        if category['ext_id'] == categoryId:\n                            vmList.append({'name': item['name'], 'ext_id': item['ext_id']})\n        page += 1\n\n    return vmList\n\n# Function to get category ID by name and value\ndef getCategoryId(name, value):\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_prism_py_client.ApiClient(configuration=sdkConfig)\n    categoriesApi = ntnx_prism_py_client.CategoriesApi(api_client=client)\n\n    try:\n        apiResponse = categoriesApi.get_all_categories(_page=page, _limit=limitPerPage, _filter=\"((value eq '\"+value+\"') and (key eq '\"+name+\"'))\")\n        if apiResponse.to_dict()['data']:\n            return apiResponse.to_dict()['data'][0]['ext_id']\n        else:\n            return None\n    except ntnx_prism_py_client.rest.ApiException as e:\n        print(e)\n\n# Function to clone a VM by its ID\ndef cloneVmById(vmId, networkExtId, vmName, powerup=False):\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    try:\n        # Retrieve the VM\n        vm = vmApi.get_vm_by_ext_id(extId=vmId)\n        etagValue = client.get_etag(vm)\n\n        # Define the NIC\n        nics = [\n            Nic(\n                network_info=NicNetworkInfo(\n                    subnet=SubnetReference(ext_id=networkExtId)\n                )\n            )\n        ]\n\n        cloneConfig = CloneOverrideParams(\n            name=vmName,\n            nics=nics,\n        )\n\n        vmApi.clone_vm(extId=vmId, body=cloneConfig, if_match=etagValue, async_req=False)\n        time.sleep(3)\n\n        #retrieve the category ID matching\n        categoryFloatingIPExtId = getCategoryId(categoryFloatingIPName, 'yes')\n\n        if powerup:\n            # we get cloneId\n            found=False\n            while not found:\n                response = vmApi.list_vms(_filter=\"name eq '\"+vmName+\"'\")\n                myData = response.to_dict()\n\n                if myData['data']:\n                    found = True\n        \n            clonedVMUUID = myData['data'][0]['ext_id']\n            getClonedVM = vmApi.get_vm_by_ext_id(extId=clonedVMUUID)\n            etagCloneValue = client.get_etag(getClonedVM)\n\n            print(\"Powering up the VM\")\n            vmApi.power_on_vm(extId=clonedVMUUID,if_match=etagCloneValue,async_req=False)\n\n        #check if source VM has the floating IP category\n        if vm.data.categories is not None:\n            for category in vm.data.categories:\n                if category.ext_id == categoryFloatingIPExtId:\n                    print(\"Assigning floating IP to VM\")\n                    assignFloatingIp(vmName)\n\n    except VMMException as e:\n        print(e)\n\n# Function to create a default route\ndef createDefaultRoute(vpcId):\n    externalNetworkId = retrieveNetworkId(externalNetworkName)\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    routeApi = ntnx_networking_py_client.RouteTablesApi(api_client=client)\n\n    routeTableResponse = routeApi.list_route_tables(_filter=\"vpcReference eq '\" + vpcId + \"'\")\n    routeTableId = routeTableResponse.data[0].ext_id  # Access the ext_id correctly\n\n    # Fetch the full routeTable object by its ID\n    routeTable = routeApi.get_route_table_by_id(routeTableId).data\n    etagValue = client.get_etag(routeTable)\n\n    # Create a new route\n    new_route = v4NetConfig.Route.Route(\n        is_active=True,\n        priority=32768,\n        destination=v4NetConfig.IPSubnet.IPSubnet(\n           ipv4=v4NetConfig.IPv4Subnet.IPv4Subnet(\n                ip=v1CommonConfig.IPv4Address.IPv4Address(\n                    prefix_length=24,\n                    value=\"0.0.0.0\",\n                ),\n                prefix_length=24\n            )\n        ),\n        nexthop_type=\"EXTERNAL_SUBNET\",\n        nexthop_reference=externalNetworkId,\n        nexthop_ip_address=None,\n        nexthop_name=externalNetworkName\n    )\n\n    # Check if static_routes exist and append the new route\n    if hasattr(routeTable, 'static_routes') and routeTable.static_routes:\n        routeTable.static_routes.append(new_route)\n    else:\n        routeTable.static_routes = [new_route]  # Initialize if empty\n\n    routeApi.update_route_table_by_id(routeTable.ext_id, body=routeTable, if_match=etagValue)\n\n# Function to create a floating IP\ndef assignFloatingIp(name):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    floatingIpApi = ntnx_networking_py_client.FloatingIpsApi(api_client=client)\n\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n\n    floatingIpConfig = v4NetConfig.FloatingIp.FloatingIp()\n    vmNicAssociation = v4NetConfig.VmNicAssociation.VmNicAssociation()\n\n    elapsed_time = 0    # time elapsed since the start of the retries\n    while elapsed_time < max_wait_time:\n        if vmApi.list_vms(_filter=\"name eq '\" + name + \"'\").data is not None:\n\n            vmNicAssociation.vm_nic_reference = vmApi.list_vms(_filter=\"name eq '\" + name + \"'\").data[0].nics[0].ext_id\n            break\n\n        print(\"waiting for VM to be created to assign floating IP\")\n\n        # Wait for the specified interval before retrying\n        time.sleep(interval)\n        elapsed_time += interval  # Update the elapsed time\n\n    floatingIpConfig.name = name\n    floatingIpConfig.external_subnet_reference = retrieveNetworkId(externalNetworkName)\n    floatingIpConfig.association = vmNicAssociation\n\n    try:\n        floatingIpApi.create_floating_ip(body=floatingIpConfig)\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n# Main execution function\ndef main():\n    vpcId = createVpc(vpcName)\n    vpcId = waitForVpcCreation(vpcName)\n    print(\"VPC Created\")\n\n    # Create the VPC network\n    for key, value in subnetList.items():\n        createOverlaySubnet(\n            vpcId,\n            key,\n            value['ipNetwork'],\n            value['ipPrefix'],\n            value['ipGateway'],\n            value['ipPoolStart'],\n            value['ipPoolEnd']\n        )\n\n    print(\"Get VM list from category %s=%s\" % (categoryName, categoryValue))\n    vmList = getVmsByCategories(categoryName, categoryValue)\n    print(\"Done...\")\n\n    vpcSubnets = retrieveVpcSubnets(vpcId)\n\n    print(\"Cloning VM...\")\n    for vm in vmList:\n        cloneVmById(vm['ext_id'], vpcSubnets[0]['ext_id'], \"clone-\" + vm['name'], powerup=True)\n\n\t#skip the route creation for now as the endpoint changed with PC 2024.2 but no SDK is yet published\n    #createDefaultRoute(vpcId)\n\n    print(\"Done. %s VMs have been cloned\" % len(vmList))\n\nif __name__ == \"__main__\":\n    main()\n","script_type":"python_remote","command_line_args":"","exit_status":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"exec_target_reference":{"name":"gamemachiine","kind":"app_endpoint"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"f64c37e3_dag","kind":"app_task"},"variable_list":[]},"critical":false},{"type":"system","name":"action_delete","description":"System action for deleting an application. Deletes created VMs as well","runbook":{"name":"da527b27_runbook","description":"","task_definition_list":[{"type":"DAG","name":"3e572388_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[{"name":"Cleanup the VPC","kind":"app_task"}],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"timeout_secs":"0","retries":"0","inherit_target":false},{"type":"EXEC","name":"Cleanup the VPC","description":"","attrs":{"type":"","script":"#!\/usr\/bin\/env python\n\nimport math\nimport os\nimport time\n\nfrom dotenv import load_dotenv\nimport ntnx_networking_py_client\nimport ntnx_vmm_py_client\nfrom ntnx_vmm_py_client.rest import ApiException as VMMException\n\n# Load environment variables\nload_dotenv()\n\n# Customizable variables\nprismCentralIp = \"@@{pcAddress}@@\"  # Prism Central IP\npcUsername = \"@@{pcUser.username}@@\"  # Nutanix username\npcPassword = \"@@{pcUser.secret}@@\"  # Nutanix password\nvpcName = \"@@{vpcName}@@\"\n\n#########################################\n# SDK Client Configuration\n#########################################\n\n# Configure the client\nsdkConfig = ntnx_networking_py_client.Configuration()\nsdkConfig.host = prismCentralIp\nsdkConfig.port = 9440\nsdkConfig.maxRetryAttempts = 3\nsdkConfig.backoffFactor = 3\nsdkConfig.username = pcUsername\nsdkConfig.password = pcPassword\nsdkConfig.verify_ssl = False\n\n\n# Function to retrieve VPC ID\ndef getVpcId(vpcName):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n\n    for vpc in vpcsApi.list_vpcs().data:\n        if vpc.name == vpcName:\n            return vpc._ExternalizableAbstractModel__ext_id\n    return False\n\n\n# Function to retrieve subnets in a VPC\ndef retrieveVpcSubnets(vpcId):\n    subnetList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    while page < nbPages:\n        response = subnetApi.list_subnets(_page=page, _limit=limitPerPage, _filter=\"vpcReference eq '\" + vpcId + \"'\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        if myData['data'] is not None:\n            for item in myData['data']:\n                subnetList.append({'name': item['name'], 'ext_id': item['ext_id']})\n\n        page += 1\n\n    return subnetList\n\n\n# Function to delete VMs by subnet ID\ndef deleteVmsBySubnet(networkExtId):\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    try:\n        listVMs = vmApi.list_vms(_filter=\"nics\/any(d:d\/networkInfo\/subnet\/extId eq '%s')\" % networkExtId)\n\n        # Delete the VMs in the subnet if they exist\n        if listVMs.data is not None:\n            for vm in listVMs.data:\n                print(\"The following VM will be deleted: %s\" % vm.name)\n                etagValue = client.get_etag(vmApi.get_vm_by_ext_id(extId=vm.ext_id))\n                vmApi.delete_vm(vm.ext_id, if_match=etagValue)\n\n        # Check every 1 second if all VMs on this subnet are deleted, with a timeout of 60 seconds\n        timeout = 60\n        start_time = time.time()\n        while True:\n            listVMs = vmApi.list_vms(_filter=\"nics\/any(d:d\/networkInfo\/subnet\/extId eq '%s')\" % networkExtId)\n            if not listVMs.data:\n                return True\n            if time.time() - start_time > timeout:\n                return False\n            print(\"Wait for VM deletion\")\n            time.sleep(1)\n\n    except VMMException as e:\n        print(e)\n\n\n# Function to delete a subnet by its ID\ndef deleteSubnetById(subnetExtId):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    try:\n        print(\"The following subnet will be deleted: %s\" % subnetExtId)\n        subnetApi.delete_subnet_by_id(subnetExtId)\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n\n# Function to delete a VPC by its ID\ndef deleteVpcById(vpcId):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n\n    try:\n        print(\"The following VPC will be deleted: %s\" % vpcId)\n        vpcsApi.delete_vpc_by_id(vpcId)\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n\n# Main execution function\ndef main():\n    vpcId = getVpcId(vpcName)\n\n    if vpcId != False:\n        vpcSubnets = retrieveVpcSubnets(vpcId)\n\n        for subnet in vpcSubnets:\n            deleteVmsBySubnet(subnet['ext_id'])\n            deleteSubnetById(subnet['ext_id'])\n\n        deleteVpcById(vpcId)\n\n        print(\"VPC %s has been deleted\" % vpcName)\n\n\nif __name__ == \"__main__\":\n    main()\n","script_type":"python_remote","command_line_args":"","exit_status":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"exec_target_reference":{"name":"gamemachiine","kind":"app_endpoint"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"3e572388_dag","kind":"app_task"},"variable_list":[]},"critical":false},{"type":"system","name":"action_start","description":"System action for starting an application","runbook":{"name":"132d845b_runbook","description":"","task_definition_list":[{"type":"DAG","name":"44cd47c9_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"44cd47c9_dag","kind":"app_task"},"variable_list":[]},"critical":false},{"type":"system","name":"action_stop","description":"System action for stopping an application","runbook":{"name":"d5a16d30_runbook","description":"","task_definition_list":[{"type":"DAG","name":"7304a944_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"7304a944_dag","kind":"app_task"},"variable_list":[]},"critical":false},{"type":"system","name":"action_restart","description":"System action for restarting an application","runbook":{"name":"deb2d749_runbook","description":"","task_definition_list":[{"type":"DAG","name":"72f80695_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"72f80695_dag","kind":"app_task"},"variable_list":[]},"critical":false}],"depends_on_list":[],"port_list":[],"singleton":false,"tier":""}],"published_service_definition_list":[],"substrate_definition_list":[{"type":"EXISTING_VM","name":"VM1","description":"","variable_list":[],"action_list":[],"create_spec":{"type":"","address":"127.0.0.1"},"os_type":"Linux","readiness_probe":{"connection_type":"SSH","connection_port":22,"delay_secs":"60","retries":"5","address":"@@{ip_address}@@","disable_readiness_probe":true,"connection_protocol":""}}],"package_definition_list":[{"type":"DEB","name":"Package1","description":"","variable_list":[],"action_list":[],"service_local_reference_list":[{"name":"Service1","kind":"app_service"}],"version":"","options":{"type":"","install_runbook":{"name":"f5518c37_runbook","description":"","task_definition_list":[{"type":"DAG","name":"6b840d8d_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Package1","kind":"app_package"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"6b840d8d_dag","kind":"app_task"},"variable_list":[]},"uninstall_runbook":{"name":"91bc1935_runbook","description":"","task_definition_list":[{"type":"DAG","name":"d7706349_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Package1","kind":"app_package"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"d7706349_dag","kind":"app_task"},"variable_list":[]},"upgrade_runbook":{}}}],"app_profile_list":[{"name":"Default","description":"","variable_list":[{"type":"EXEC_LOCAL","name":"categoryFloatingIPName","description":"","regex":{"value":"^.*$","should_validate":false},"options":{"type":"EXEC","attrs":{"type":"EXEC","script":"# Variables from the environment\npc_address = \"@@{pcAddress}@@\"\nusername = \"@@{pcUser.username}@@\"\npassword = \"@@{pcUser.secret}@@\"\n\n# Function to make GET requests using urlreq\ndef get_request(api_url, username, password):\n    try:\n        # Make the GET request with basic authentication\n        response = urlreq(api_url, verb='GET', auth=\"BASIC\", user=username, passwd=password, verify=False)\n        if response.ok:\n            # Parse JSON content\n            return json.loads(response.content)\n        else:\n            print(f\"Error: {response.status_code} - {response.content}\")\n            exit(1)\n    except Exception as err:\n        print(f\"Error making API request: {err}\")\n        exit(1)\n\n# Initialize variables for pagination\npage = 0\nall_keys = set()  # Use a set to store unique keys\n\nwhile True:\n    # Construct the API URL with pagination\n    api_url = f\"https:\/\/{pc_address}:9440\/api\/prism\/v4.0.b1\/config\/categories?$select=key&$page={page}\"\n    \n    # Make the GET request to retrieve the category keys\n    response_data = get_request(api_url, username, password)\n\n    # Check if there is data returned\n    if 'data' in response_data and response_data['data']:\n        # Extract the 'key' values and add them to the set\n        keys = {item['key'] for item in response_data['data']}\n        all_keys.update(keys)  # Add new keys to the set (automatically removes duplicates)\n        page += 1  # Increment the page number\n    else:\n        break  # Exit the loop if no data is returned\n\n# Print the unique keys as a comma-separated string, sorted alphabetically\nprint(\",\".join(sorted(all_keys)))","script_type":"static_py3","command_line_args":"","exit_status":[]}},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"editables":{"value":true},"value":""},{"type":"HTTP_LOCAL","name":"externalNetworkName","description":"","regex":{"value":"^.*$","should_validate":false},"options":{"type":"HTTP","attrs":{"type":"HTTP","method":"GET","connection_timeout":120,"headers":[],"url":"https:\/\/@@{pcAddress}@@:9440\/api\/networking\/v4.0.b1\/config\/subnets","request_body":"","content_type":"application\/json","expected_response_params":[{"type":"","code":200,"status":"SUCCESS"}],"authentication":{"type":"basic_with_cred","credential_local_reference":{"name":"pcUser","kind":"app_credential"}},"response_paths":{"externalNetworkName":"$.data[*].name"},"tls_verify":false,"proxy_type":"","retry_count":1,"retry_interval":1}},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"editables":{"value":true},"value":""},{"type":"EXEC_LOCAL","name":"categoryValue","description":"","options":{"type":"EXEC","attrs":{"type":"EXEC","script":"# Variables from the environment\npc_address = \"@@{pcAddress}@@\"\nusername = \"@@{pcUser.username}@@\"\npassword = \"@@{pcUser.secret}@@\"\n\n# Function to make GET requests using urlreq\ndef get_request(api_url, username, password):\n    try:\n        # Make the GET request with basic authentication\n        response = urlreq(api_url, verb='GET', auth=\"BASIC\", user=username, passwd=password, verify=False)\n        if response.ok:\n            # Parse JSON content\n            return json.loads(response.content)\n        else:\n            print(f\"Error: {response.status_code} - {response.content}\")\n            exit(1)\n    except Exception as err:\n        print(f\"Error making API request: {err}\")\n        exit(1)\n\n# Initialize variables for pagination\npage = 0\nall_values = set()  # Use a set to store unique keys\n\nwhile True:\n    # Construct the API URL with pagination\n    api_url = f\"https:\/\/{pc_address}:9440\/api\/prism\/v4.0.b1\/config\/categories?$select=value&$filter=key eq '@@{categoryName}@@'&$page={page}\"\n    \n    # Make the GET request to retrieve the category keys\n    response_data = get_request(api_url, username, password)\n\n    # Check if there is data returned\n    if 'data' in response_data and response_data['data']:\n        # Extract the 'key' values and add them to the set\n        values = {item['value'] for item in response_data['data']}\n        all_values.update(values)  # Add new keys to the set (automatically removes duplicates)\n        page += 1  # Increment the page number\n    else:\n        break  # Exit the loop if no data is returned\n\n# Print the unique keys as a comma-separated string, sorted alphabetically\nprint(\",\".join(sorted(all_values)))","script_type":"static_py3","command_line_args":"","exit_status":[]}},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"editables":{"value":true},"value":""},{"type":"EXEC_LOCAL","name":"categoryName","description":"","options":{"type":"EXEC","attrs":{"type":"EXEC","script":"# Variables from the environment\npc_address = \"@@{pcAddress}@@\"\nusername = \"@@{pcUser.username}@@\"\npassword = \"@@{pcUser.secret}@@\"\n\n# Function to make GET requests using urlreq\ndef get_request(api_url, username, password):\n    try:\n        # Make the GET request with basic authentication\n        response = urlreq(api_url, verb='GET', auth=\"BASIC\", user=username, passwd=password, verify=False)\n        if response.ok:\n            # Parse JSON content\n            return json.loads(response.content)\n        else:\n            print(f\"Error: {response.status_code} - {response.content}\")\n            exit(1)\n    except Exception as err:\n        print(f\"Error making API request: {err}\")\n        exit(1)\n\n# Initialize variables for pagination\npage = 0\nall_keys = set()  # Use a set to store unique keys\n\nwhile True:\n    # Construct the API URL with pagination\n    api_url = f\"https:\/\/{pc_address}:9440\/api\/prism\/v4.0.b1\/config\/categories?$select=key&$page={page}\"\n    \n    # Make the GET request to retrieve the category keys\n    response_data = get_request(api_url, username, password)\n\n    # Check if there is data returned\n    if 'data' in response_data and response_data['data']:\n        # Extract the 'key' values and add them to the set\n        keys = {item['key'] for item in response_data['data']}\n        all_keys.update(keys)  # Add new keys to the set (automatically removes duplicates)\n        page += 1  # Increment the page number\n    else:\n        break  # Exit the loop if no data is returned\n\n# Print the unique keys as a comma-separated string, sorted alphabetically\nprint(\",\".join(sorted(all_keys)))","script_type":"static_py3","command_line_args":"","exit_status":[]}},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"editables":{"value":true},"value":""},{"type":"LOCAL","name":"vpcName","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"editables":{"value":true},"value":"@@{calm_application_name}@@"},{"type":"LOCAL","name":"pcAddress","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":false,"data_type":"BASE","val_type":"STRING","label":"","attrs":{"type":""},"value":"10.38.228.39"}],"action_list":[{"type":"user","name":"Refresh machines","description":"","runbook":{"name":"3f9657f9_runbook","description":"","task_definition_list":[{"type":"DAG","name":"9dc7f18f_dag","description":"","attrs":{"type":"","edges":[{"type":"","from_task_reference":{"name":"Delete Test VMs","kind":"app_task"},"to_task_reference":{"name":"Clone VMs","kind":"app_task"},"edge_type":"user_defined"}]},"child_tasks_local_reference_list":[{"name":"Clone VMs","kind":"app_task"},{"name":"Delete Test VMs","kind":"app_task"}],"variable_list":[],"timeout_secs":"0","retries":"0","inherit_target":false},{"type":"EXEC","name":"Clone VMs","description":"","attrs":{"type":"","script":"#!\/usr\/bin\/env python\n\nimport os\nimport time\nimport math\n\nfrom dotenv import load_dotenv\nimport ntnx_networking_py_client\nimport ntnx_vmm_py_client\nimport ntnx_prism_py_client\nimport ntnx_networking_py_client.models\nimport ntnx_networking_py_client.models.networking\nimport ntnx_networking_py_client.models.common.v1.config as v1CommonConfig\nimport ntnx_networking_py_client.models.networking.v4.config as v4NetConfig\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.CloneOverrideParams import CloneOverrideParams\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.Nic import Nic\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.NicNetworkInfo import NicNetworkInfo\nfrom ntnx_vmm_py_client.models.vmm.v4.ahv.config.SubnetReference import SubnetReference\nfrom ntnx_vmm_py_client.rest import ApiException as VMMException\n\nimport urllib3\nurllib3.disable_warnings()\n\n# Load environment variables\nload_dotenv()\n\n#Customizable variables\nprismCentralIp = \"@@{pcAddress}@@\"  # Prism Central IP\npcUsername = \"@@{pcUser.username}@@\"  # Nutanix username\npcPassword = \"@@{pcUser.secret}@@\"  # Nutanix password\nvpcName = \"@@{vpcName}@@\"\ncategoryName = \"@@{categoryName}@@\"\ncategoryValue = \"@@{categoryValue}@@\"\nexternalNetworkName = \"@@{externalNetworkName}@@\"\ncategoryFloatingIPName = \"@@{categoryFloatingIPName}@@\"\n# Retry parameters\nmax_wait_time = 60  # maximum wait time in seconds\ninterval = 1        # interval between retries in seconds\n\n# Subnet configuration\nsubnetList = {\n    \"vpc-\"+vpcName+\"-subnet\": {\n        \"subnetDescription\": \"This is the overlay subnet\",\n        \"ipNetwork\": \"172.24.0.0\",\n        \"ipPrefix\": 16,\n        \"ipGateway\": \"172.24.0.1\",\n        \"ipPoolStart\": \"172.24.32.10\",\n        \"ipPoolEnd\": \"172.24.47.254\"\n    },\n}\n\n#########################################\n# SDK Client Configuration\n#########################################\n\n# Configure the client\nsdkConfig = ntnx_networking_py_client.Configuration()\nsdkConfig.host = prismCentralIp\nsdkConfig.port = 9440\nsdkConfig.maxRetryAttempts = 3\nsdkConfig.backoffFactor = 3\nsdkConfig.username = pcUsername\nsdkConfig.password = pcPassword\nsdkConfig.verify_ssl = False\n\n# Function to create a VPC\ndef createVpc(vpcName):\n    print(\"Creating VPC: %s\" % vpcName)\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n    vpc = ntnx_networking_py_client.Vpc()\n    externalSubnet = ntnx_networking_py_client.ExternalSubnet()\n    externalSubnet.subnet_reference = retrieveNetworkId(externalNetworkName)\n    vpc.name = vpcName  # Required field\n    vpc.external_subnets = [externalSubnet]\n\n    try:\n        response = vpcsApi.create_vpc(body=vpc)\n        return True\n    except ntnx_networking_py_client.rest.ApiException as e:\n        return False\n\n# Function to check if a VPC exists\ndef checkVpcExists(vpcData, vpcName):\n    if vpcData:\n      for vpc in vpcData:\n          if vpc.name == vpcName:\n              return vpc._ExternalizableAbstractModel__ext_id\n    return False\n\n# Function to wait for VPC creation\ndef getVpcId(vpcName, timeout=3000, interval=1):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n    vpcs = vpcsApi.list_vpcs()\n\n    elapsedTime = 0\n    while elapsedTime < timeout:\n        vpcId = checkVpcExists(vpcs.data, vpcName)\n        if vpcId:\n            return vpcId\n        else:\n            time.sleep(interval)\n            elapsedTime += interval\n\n    return False\n\n# Function to create an overlay subnet\ndef createOverlaySubnet(vpcId, subnetName, ipNetwork, ipPrefix, ipGateway, ipPoolStart, ipPoolEnd):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetsApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n    subnet = ntnx_networking_py_client.Subnet()\n\n    print(\"Creating overlay subnet...\")\n\n    # Set up the subnet configuration\n    subnet.name = subnetName\n    subnet.subnet_type = ntnx_networking_py_client.SubnetType.OVERLAY  # Required field\n    subnet.vpc_reference = vpcId\n\n    subnet.ip_config = [\n        v4NetConfig.IPConfig.IPConfig(\n            ipv4=v4NetConfig.IPv4Config.IPv4Config(\n                default_gateway_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                    prefix_length=ipPrefix,\n                    value=ipGateway,\n                ),\n                ip_subnet=v4NetConfig.IPv4Subnet.IPv4Subnet(\n                    ip=v1CommonConfig.IPv4Address.IPv4Address(\n                        prefix_length=ipPrefix,\n                        value=ipNetwork,\n                    ),\n                    prefix_length=ipPrefix,\n                ),\n                pool_list=[\n                    v4NetConfig.IPv4Pool.IPv4Pool(\n                        start_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                            prefix_length=ipPrefix,\n                            value=ipPoolStart,\n                        ),\n                        end_ip=v1CommonConfig.IPv4Address.IPv4Address(\n                            prefix_length=ipPrefix,\n                            value=ipPoolEnd,\n                        )\n                    )\n                ],\n            )\n        )\n    ]\n\n    try:\n        subnetsApi.create_subnet(body=subnet)\n        print(\"Done...\")\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n# Function to retrieve subnets in a VPC\ndef retrieveVpcSubnets(vpcId, timeout=3000, interval=1):\n    subnetList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    while page < nbPages:\n        response = subnetApi.list_subnets(_page=page, _limit=limitPerPage, _filter=\"vpcReference eq '\" + vpcId + \"'\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        for item in myData['data']:\n            subnetList.append({'name': item['name'], 'ext_id': item['ext_id']})\n        page += 1\n\n    return subnetList\n\n# Function to retrieve the extId of a specific subnet\ndef retrieveNetworkId(networkName):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    response = subnetApi.list_subnets(_filter=\"name eq '\" + str(networkName) + \"'\")\n    myData = response.to_dict()\n\n    if myData['data']:\n        return myData['data'][0]['ext_id']\n    else:\n        return None\n\n# Function to get VMs by categories\ndef getVmsByCategories(categoryName, categoryValue):\n    vmList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    categoryId = getCategoryId(categoryName, categoryValue)\n\n    while page < nbPages:\n        # Temporary filter only on VM starting with 'hol' to bypass the UEFI issue\n        response = vmApi.list_vms(_page=page, _limit=limitPerPage, _orderby=\"name asc\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        if myData['data'] and len(myData['data']):\n            for item in myData['data']:\n                if item.get('categories') is not None:\n                    for category in item['categories']:\n                        if category['ext_id'] == categoryId:\n                            vmList.append({'name': item['name'], 'ext_id': item['ext_id']})\n        page += 1\n\n    return vmList\n\n# Function to get category ID by name and value\ndef getCategoryId(name, value):\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_prism_py_client.ApiClient(configuration=sdkConfig)\n    categoriesApi = ntnx_prism_py_client.CategoriesApi(api_client=client)\n\n    try:\n        apiResponse = categoriesApi.get_all_categories(_page=page, _limit=limitPerPage, _filter=\"((value eq '\"+value+\"') and (key eq '\"+name+\"'))\")\n        if apiResponse.to_dict()['data']:\n            return apiResponse.to_dict()['data'][0]['ext_id']\n        else:\n            return None\n    except ntnx_prism_py_client.rest.ApiException as e:\n        print(e)\n\n# Function to clone a VM by its ID\ndef cloneVmById(vmId, networkExtId, vmName, powerup=False):\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    try:\n        # Retrieve the VM\n        vm = vmApi.get_vm_by_ext_id(extId=vmId)\n        etagValue = client.get_etag(vm)\n\n        # Define the NIC\n        nics = [\n            Nic(\n                network_info=NicNetworkInfo(\n                    subnet=SubnetReference(ext_id=networkExtId)\n                )\n            )\n        ]\n\n        cloneConfig = CloneOverrideParams(\n            name=vmName,\n            nics=nics,\n        )\n\n        vmApi.clone_vm(extId=vmId, body=cloneConfig, if_match=etagValue, async_req=False)\n        time.sleep(3)\n\n        #retrieve the category ID matching\n        categoryFloatingIPExtId = getCategoryId(categoryFloatingIPName, 'yes')\n\n        if powerup:\n            # we get cloneId\n            found=False\n            while not found:\n                response = vmApi.list_vms(_filter=\"name eq '\"+vmName+\"'\")\n                myData = response.to_dict()\n\n                if myData['data']:\n                    found = True\n        \n            clonedVMUUID = myData['data'][0]['ext_id']\n            getClonedVM = vmApi.get_vm_by_ext_id(extId=clonedVMUUID)\n            etagCloneValue = client.get_etag(getClonedVM)\n\n            print(\"Powering up the VM\")\n            vmApi.power_on_vm(extId=clonedVMUUID,if_match=etagCloneValue,async_req=False)\n\n        #check if source VM has the floating IP category\n        if vm.data.categories is not None:\n            for category in vm.data.categories:\n                if category.ext_id == categoryFloatingIPExtId:\n                    print(\"Assigning floating IP to VM\")\n                    assignFloatingIp(vmName)\n\n    except VMMException as e:\n        print(e)\n\n# Function to create a default route\ndef createDefaultRoute(vpcId):\n    externalNetworkId = retrieveNetworkId(externalNetworkName)\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    routeApi = ntnx_networking_py_client.RouteTablesApi(api_client=client)\n\n    routeTableResponse = routeApi.list_route_tables(_filter=\"vpcReference eq '\" + vpcId + \"'\")\n    routeTableId = routeTableResponse.data[0].ext_id  # Access the ext_id correctly\n\n    # Fetch the full routeTable object by its ID\n    routeTable = routeApi.get_route_table_by_id(routeTableId).data\n    etagValue = client.get_etag(routeTable)\n\n    # Create a new route\n    new_route = v4NetConfig.Route.Route(\n        is_active=True,\n        priority=32768,\n        destination=v4NetConfig.IPSubnet.IPSubnet(\n           ipv4=v4NetConfig.IPv4Subnet.IPv4Subnet(\n                ip=v1CommonConfig.IPv4Address.IPv4Address(\n                    prefix_length=24,\n                    value=\"0.0.0.0\",\n                ),\n                prefix_length=24\n            )\n        ),\n        nexthop_type=\"EXTERNAL_SUBNET\",\n        nexthop_reference=externalNetworkId,\n        nexthop_ip_address=None,\n        nexthop_name=externalNetworkName\n    )\n\n    # Check if static_routes exist and append the new route\n    if hasattr(routeTable, 'static_routes') and routeTable.static_routes:\n        routeTable.static_routes.append(new_route)\n    else:\n        routeTable.static_routes = [new_route]  # Initialize if empty\n\n    routeApi.update_route_table_by_id(routeTable.ext_id, body=routeTable, if_match=etagValue)\n\n# Function to create a floating IP\ndef assignFloatingIp(name):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    floatingIpApi = ntnx_networking_py_client.FloatingIpsApi(api_client=client)\n\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n\n    floatingIpConfig = v4NetConfig.FloatingIp.FloatingIp()\n    vmNicAssociation = v4NetConfig.VmNicAssociation.VmNicAssociation()\n\n    elapsed_time = 0    # time elapsed since the start of the retries\n    while elapsed_time < max_wait_time:\n        if vmApi.list_vms(_filter=\"name eq '\" + name + \"'\").data is not None:\n\n            vmNicAssociation.vm_nic_reference = vmApi.list_vms(_filter=\"name eq '\" + name + \"'\").data[0].nics[0].ext_id\n            break\n\n        print(\"waiting for VM to be created to assign floating IP\")\n\n        # Wait for the specified interval before retrying\n        time.sleep(interval)\n        elapsed_time += interval  # Update the elapsed time\n\n    floatingIpConfig.name = name\n    floatingIpConfig.external_subnet_reference = retrieveNetworkId(externalNetworkName)\n    floatingIpConfig.association = vmNicAssociation\n\n    try:\n        floatingIpApi.create_floating_ip(body=floatingIpConfig)\n    except ntnx_networking_py_client.rest.ApiException as e:\n        print(e)\n\n# Main execution function\ndef main():\n\n    vpcId = getVpcId(vpcName)\n\n    print(\"Get VM list from category %s=%s\" % (categoryName, categoryValue))\n    vmList = getVmsByCategories(categoryName, categoryValue)\n    print(\"Done...\")\n\n    vpcSubnets = retrieveVpcSubnets(vpcId)\n\n    print(\"Cloning VM...\")\n    for vm in vmList:\n        cloneVmById(vm['ext_id'], vpcSubnets[0]['ext_id'], \"clone-\" + vm['name'], powerup=True)\n\n\t#skip the route creation for now as the endpoint changed with PC 2024.2 but no SDK is yet published\n    #createDefaultRoute(vpcId)\n\n    print(\"Done. %s VMs have been cloned\" % len(vmList))\n\nif __name__ == \"__main__\":\n    main()\n","script_type":"python_remote","command_line_args":"","exit_status":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"exec_target_reference":{"name":"gamemachiine","kind":"app_endpoint"},"timeout_secs":"0","retries":"0","inherit_target":false},{"type":"EXEC","name":"Delete Test VMs","description":"","attrs":{"type":"","script":"#!\/usr\/bin\/env python\n\nimport math\nimport os\nimport time\n\nfrom dotenv import load_dotenv\nimport ntnx_networking_py_client\nimport ntnx_vmm_py_client\nfrom ntnx_vmm_py_client.rest import ApiException as VMMException\n\n# Load environment variables\nload_dotenv()\n\n# Customizable variables\nprismCentralIp = \"@@{pcAddress}@@\"  # Prism Central IP\npcUsername = \"@@{pcUser.username}@@\"  # Nutanix username\npcPassword = \"@@{pcUser.secret}@@\"  # Nutanix password\nvpcName = \"@@{vpcName}@@\"\n\n#########################################\n# SDK Client Configuration\n#########################################\n\n# Configure the client\nsdkConfig = ntnx_networking_py_client.Configuration()\nsdkConfig.host = prismCentralIp\nsdkConfig.port = 9440\nsdkConfig.maxRetryAttempts = 3\nsdkConfig.backoffFactor = 3\nsdkConfig.username = pcUsername\nsdkConfig.password = pcPassword\nsdkConfig.verify_ssl = False\n\n\n# Function to retrieve VPC ID\ndef getVpcId(vpcName):\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    vpcsApi = ntnx_networking_py_client.VpcsApi(api_client=client)\n\n    for vpc in vpcsApi.list_vpcs().data:\n        if vpc.name == vpcName:\n            return vpc._ExternalizableAbstractModel__ext_id\n    return False\n\n\n# Function to retrieve subnets in a VPC\ndef retrieveVpcSubnets(vpcId):\n    subnetList = []\n    nbPages = 10000\n    page = 0\n    limitPerPage = 50\n\n    client = ntnx_networking_py_client.ApiClient(configuration=sdkConfig)\n    subnetApi = ntnx_networking_py_client.SubnetsApi(api_client=client)\n\n    while page < nbPages:\n        response = subnetApi.list_subnets(_page=page, _limit=limitPerPage, _filter=\"vpcReference eq '\" + vpcId + \"'\")\n        myData = response.to_dict()\n\n        nbPages = math.ceil(myData['metadata']['total_available_results'] \/ limitPerPage)\n\n        if myData['data'] is not None:\n            for item in myData['data']:\n                subnetList.append({'name': item['name'], 'ext_id': item['ext_id']})\n\n        page += 1\n\n    return subnetList\n\n\n# Function to delete VMs by subnet ID\ndef deleteVmsBySubnet(networkExtId):\n    client = ntnx_vmm_py_client.ApiClient(configuration=sdkConfig)\n    vmApi = ntnx_vmm_py_client.VmApi(api_client=client)\n\n    try:\n        listVMs = vmApi.list_vms(_filter=\"nics\/any(d:d\/networkInfo\/subnet\/extId eq '%s')\" % networkExtId)\n\n        # Delete the VMs in the subnet if they exist\n        if listVMs.data is not None:\n            for vm in listVMs.data:\n                print(\"The following VM will be deleted: %s\" % vm.name)\n                etagValue = client.get_etag(vmApi.get_vm_by_ext_id(extId=vm.ext_id))\n                vmApi.delete_vm(vm.ext_id, if_match=etagValue)\n\n        # Check every 1 second if all VMs on this subnet are deleted, with a timeout of 60 seconds\n        timeout = 60\n        start_time = time.time()\n        while True:\n            listVMs = vmApi.list_vms(_filter=\"nics\/any(d:d\/networkInfo\/subnet\/extId eq '%s')\" % networkExtId)\n            if not listVMs.data:\n                return True\n            if time.time() - start_time > timeout:\n                return False\n            print(\"Wait for VM deletion\")\n            time.sleep(1)\n\n    except VMMException as e:\n        print(e)\n\n\n# Main execution function\ndef main():\n    vpcId = getVpcId(vpcName)\n\n    if vpcId != False:\n        vpcSubnets = retrieveVpcSubnets(vpcId)\n\n        for subnet in vpcSubnets:\n            deleteVmsBySubnet(subnet['ext_id'])\n            \n        print(\"VM have been deleted\")\n\n\nif __name__ == \"__main__\":\n    main()","script_type":"python_remote","command_line_args":"","exit_status":[]},"child_tasks_local_reference_list":[],"variable_list":[],"target_any_local_reference":{"name":"Service1","kind":"app_service"},"exec_target_reference":{"name":"gamemachiine","kind":"app_endpoint"},"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"9dc7f18f_dag","kind":"app_task"},"variable_list":[]},"critical":false}],"deployment_create_list":[{"type":"GREENFIELD","name":"deployment_3cad9f1f","description":"","variable_list":[],"action_list":[],"depends_on_list":[],"min_replicas":"1","max_replicas":"1","default_replicas":"1","package_local_reference_list":[{"name":"Package1","kind":"app_package"}],"substrate_local_reference":{"name":"VM1","kind":"app_substrate"},"published_service_local_reference_list":[]}],"snapshot_config_list":[],"restore_config_list":[],"environment_reference_list":[],"application_url":"","patch_list":[]}],"credential_definition_list":[{"type":"PASSWORD","name":"pcUser","description":"","username":"admin","secret":{"attrs":{"secret_reference":{},"is_secret_modified":false}},"cred_class":"static"}],"default_credential_local_reference":{"name":"pcUser","kind":"app_credential"},"type":"USER","client_attrs":{"deployment_3cad9f1f":{"x":635,"y":453}}}},"api_version":"3.0","product_version":"3.8.1","metadata":{"last_update_time":"1731080909399418","creation_time":"1730973082601093","spec_version":17,"name":"Clone VPC","kind":"blueprint"},"contains_secrets":false}